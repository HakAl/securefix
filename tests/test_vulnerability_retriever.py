"""
Tests for vulnerability_retriever.py

Covers:
- Hybrid retrieval (vector + BM25)
- Deduplication logic
- MMR search
- Reranking with cross-encoder
- Factory functions and caching
"""
import pytest
import numpy as np
from unittest.mock import Mock, patch
from langchain_core.documents import Document
from securefix.remediation.vulnerability_retriever import  HybridRetriever, RerankerCompressor, get_reranker, create_hybrid_retrieval_pipeline, _RERANKER_CACHE


@pytest.fixture
def sample_security_documents():
    """Sample security documents for testing"""
    return [
        Document(
            page_content="CWE-89: SQL Injection occurs when untrusted data is sent to an interpreter",
            metadata={"source": "cwe.csv", "cwe_id": "CWE-89"}
        ),
        Document(
            page_content="Use parameterized queries to prevent SQL injection attacks",
            metadata={"source": "owasp.md", "doc_type": "owasp_cheatsheet"}
        ),
        Document(
            page_content="XSS vulnerabilities allow attackers to inject malicious scripts",
            metadata={"source": "cwe.csv", "cwe_id": "CWE-79"}
        ),
        Document(
            page_content="Input validation is critical for preventing injection attacks",
            metadata={"source": "owasp.md", "doc_type": "owasp_cheatsheet"}
        ),
    ]


@pytest.fixture
def hybrid_retriever_with_bm25(mock_vector_store, mock_bm25_index, sample_security_documents):
    """Create HybridRetriever with BM25 enabled"""
    # Use model_construct to bypass Pydantic validation for testing
    retriever = HybridRetriever.model_construct(
        vector_store=mock_vector_store,
        bm25_index=mock_bm25_index,
        bm25_chunks=sample_security_documents,
        vector_k=2,
        bm25_top_k=2,
        min_docs_before_bm25=3
    )
    return retriever


@pytest.fixture
def hybrid_retriever_no_bm25(mock_vector_store):
    """Create HybridRetriever without BM25"""
    # Use model_construct to bypass Pydantic validation for testing
    retriever = HybridRetriever.model_construct(
        vector_store=mock_vector_store,
        bm25_index=None,
        bm25_chunks=[],
        vector_k=2
    )
    return retriever


class TestHybridRetrieverInitialization:
    """Test HybridRetriever initialization"""

    def test_init_with_bm25(self, mock_vector_store, mock_bm25_index, sample_security_documents):
        """Test initialization with BM25 components"""
        retriever = HybridRetriever.model_construct(
            vector_store=mock_vector_store,
            bm25_index=mock_bm25_index,
            bm25_chunks=sample_security_documents
        )

        assert retriever.vector_store == mock_vector_store
        assert retriever.bm25_index == mock_bm25_index
        assert retriever.bm25_chunks == sample_security_documents

    def test_init_without_bm25(self, mock_vector_store):
        """Test initialization without BM25"""
        retriever = HybridRetriever.model_construct(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[]
        )

        assert retriever.bm25_index is None
        assert retriever.bm25_chunks == []

    def test_init_mismatched_bm25_raises_error(self, mock_vector_store, mock_bm25_index):
        """Test that mismatched BM25 components raise error"""
        with pytest.raises(ValueError):
            retriever = HybridRetriever.model_construct(
                vector_store=mock_vector_store,
                bm25_index=mock_bm25_index,
                bm25_chunks=[]  # Index provided but no chunks
            )
            # Need to actually call __init__ to trigger validation
            retriever.__init__(
                vector_store=mock_vector_store,
                bm25_index=mock_bm25_index,
                bm25_chunks=[]
            )


class TestVectorSearch:
    """Test vector search functionality"""

    def test_vector_search_returns_documents(self, hybrid_retriever_no_bm25, sample_security_documents):
        """Test that vector search returns documents"""
        # Mock the retriever's invoke to return documents
        mock_retriever = Mock()
        mock_retriever.invoke.return_value = sample_security_documents[:2]
        hybrid_retriever_no_bm25.vector_store.as_retriever.return_value = mock_retriever

        results = hybrid_retriever_no_bm25._vector_search("SQL injection")

        assert len(results) == 2
        assert all(isinstance(doc, Document) for doc in results)

    def test_vector_search_uses_mmr(self, mock_vector_store):
        """Test that vector search uses MMR"""
        retriever = HybridRetriever.model_construct(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[]
        )

        retriever._vector_search("test query")

        # Verify as_retriever was called with MMR settings
        mock_vector_store.as_retriever.assert_called_once()
        call_kwargs = mock_vector_store.as_retriever.call_args[1]
        assert call_kwargs['search_type'] == 'mmr'


class TestBM25Search:
    """Test BM25 search functionality"""

    def test_bm25_search_returns_documents(self, hybrid_retriever_with_bm25):
        """Test that BM25 search returns documents"""
        existing_docs = []
        results = hybrid_retriever_with_bm25._bm25_search("SQL injection", existing_docs)

        assert len(results) > 0
        assert all(isinstance(doc, Document) for doc in results)

    def test_bm25_search_deduplicates(self, hybrid_retriever_with_bm25, sample_security_documents):
        """Test that BM25 search removes duplicates"""
        existing_docs = [sample_security_documents[0]]
        results = hybrid_retriever_with_bm25._bm25_search("SQL", existing_docs)

        # Should not return the already-retrieved document
        assert sample_security_documents[0] not in results

    def test_bm25_search_respects_top_k(self, hybrid_retriever_with_bm25):
        """Test that BM25 search respects top_k parameter"""
        results = hybrid_retriever_with_bm25._bm25_search("test", [])

        assert len(results) <= hybrid_retriever_with_bm25.bm25_top_k

    def test_bm25_search_without_index_returns_empty(self, hybrid_retriever_no_bm25):
        """Test BM25 search without index returns empty list"""
        results = hybrid_retriever_no_bm25._bm25_search("test", [])

        assert results == []


class TestHybridRetrieval:
    """Test hybrid retrieval combining vector and BM25"""

    def test_retrieval_vector_only_when_sufficient(self, hybrid_retriever_with_bm25, sample_security_documents):
        """Test that only vector search is used when enough docs are found"""
        # Mock vector search to return enough documents
        with patch.object(hybrid_retriever_with_bm25, '_vector_search') as mock_vector:
            mock_vector.return_value = sample_security_documents[:3]  # Enough docs

            results = hybrid_retriever_with_bm25._get_relevant_documents("test")

            # Should only use vector search, not BM25
            assert len(results) == 3
            mock_vector.assert_called_once()

    def test_retrieval_triggers_bm25_insufficient_docs(self, hybrid_retriever_with_bm25, sample_security_documents):
        """Test that BM25 is triggered when vector search returns too few docs"""
        # Mock vector search to return insufficient documents
        with patch.object(hybrid_retriever_with_bm25, '_vector_search') as mock_vector:
            with patch.object(hybrid_retriever_with_bm25, '_bm25_search') as mock_bm25:
                mock_vector.return_value = sample_security_documents[:1]  # Not enough
                mock_bm25.return_value = sample_security_documents[2:3]

                results = hybrid_retriever_with_bm25._get_relevant_documents("test")

                # Should use both vector and BM25
                mock_vector.assert_called_once()
                mock_bm25.assert_called_once()
                assert len(results) == 2

    def test_retrieval_without_bm25(self, hybrid_retriever_no_bm25, sample_security_documents):
        """Test retrieval without BM25 only uses vector search"""
        with patch.object(hybrid_retriever_no_bm25, '_vector_search') as mock_vector:
            mock_vector.return_value = sample_security_documents[:2]

            results = hybrid_retriever_no_bm25._get_relevant_documents("test")

            assert len(results) == 2
            mock_vector.assert_called_once()


class TestRerankerCompressor:
    """Test reranking functionality"""

    @patch('sentence_transformers.CrossEncoder')
    def test_reranker_initialization(self, mock_cross_encoder):
        """Test reranker initialization"""
        mock_model = Mock()
        mock_cross_encoder.return_value = mock_model

        reranker = RerankerCompressor(model_name="test-model", top_k=3)

        assert reranker.model == mock_model
        assert reranker.top_k == 3
        mock_cross_encoder.assert_called_once_with("test-model")

    @patch('sentence_transformers.CrossEncoder')
    def test_reranker_compress_returns_top_k(self, mock_cross_encoder, sample_security_documents):
        """Test that reranker returns top-k documents"""
        mock_model = Mock()
        mock_model.predict.return_value = np.array([0.9, 0.5, 0.7, 0.3])
        mock_cross_encoder.return_value = mock_model

        reranker = RerankerCompressor(top_k=2)
        results = reranker.compress(sample_security_documents, "SQL injection")

        assert len(results) == 2
        # Should return top 2 by score

    @patch('sentence_transformers.CrossEncoder')
    def test_reranker_handles_empty_list(self, mock_cross_encoder):
        """Test reranker with empty document list"""
        mock_model = Mock()
        mock_cross_encoder.return_value = mock_model

        reranker = RerankerCompressor()
        results = reranker.compress([], "test query")

        assert results == []

    @patch('sentence_transformers.CrossEncoder')
    def test_reranker_handles_single_document(self, mock_cross_encoder, sample_security_documents):
        """Test reranker with single document"""
        mock_model = Mock()
        mock_cross_encoder.return_value = mock_model

        reranker = RerankerCompressor()
        results = reranker.compress([sample_security_documents[0]], "test")

        assert len(results) == 1
        assert results[0] == sample_security_documents[0]


class TestRerankerCaching:
    """Test reranker caching functionality"""

    def teardown_method(self):
        """Clear cache after each test"""
        _RERANKER_CACHE.clear()

    def test_get_reranker_creates_instance(self):
        """Test that get_reranker creates a new instance"""
        with patch('securefix.remediation.vulnerability_retriever.RerankerCompressor') as mock_compressor:
            mock_instance = Mock()
            mock_compressor.return_value = mock_instance

            reranker = get_reranker(model_name="test-model", top_k=3)

            assert reranker == mock_instance
            mock_compressor.assert_called_once_with(model_name="test-model", top_k=3)

    def test_get_reranker_caches_instance(self):
        """Test that get_reranker caches instances"""
        with patch('securefix.remediation.vulnerability_retriever.RerankerCompressor') as mock_compressor:
            mock_instance = Mock()
            mock_compressor.return_value = mock_instance

            reranker1 = get_reranker(model_name="test-model", top_k=3)
            reranker2 = get_reranker(model_name="test-model", top_k=3)

            # Should return the same cached instance
            assert reranker1 is reranker2
            # Constructor should only be called once
            assert mock_compressor.call_count == 1

    def test_get_reranker_different_params_different_cache(self):
        """Test that different parameters create different cache entries"""
        with patch('securefix.remediation.vulnerability_retriever.RerankerCompressor') as mock_compressor:
            mock_compressor.side_effect = [Mock(), Mock()]

            reranker1 = get_reranker(model_name="model1", top_k=3)
            reranker2 = get_reranker(model_name="model2", top_k=3)

            # Should be different instances
            assert reranker1 is not reranker2
            assert mock_compressor.call_count == 2


class TestHybridRetrievalPipeline:
    """Test complete hybrid retrieval pipeline"""

    @patch('sentence_transformers.CrossEncoder')
    def test_pipeline_with_reranking(self, mock_cross_encoder, mock_vector_store):
        """Test pipeline creation with reranking enabled"""
        # Mock the CrossEncoder so RerankerCompressor can be created
        mock_model = Mock()
        mock_cross_encoder.return_value = mock_model

        retriever = create_hybrid_retrieval_pipeline(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[],
            use_reranking=True
        )

        # Should return ContextualCompressionRetriever when reranking is enabled
        from langchain.retrievers import ContextualCompressionRetriever
        assert isinstance(retriever, ContextualCompressionRetriever)

    def test_pipeline_without_reranking(self, mock_vector_store):
        """Test pipeline creation without reranking"""
        retriever = create_hybrid_retrieval_pipeline(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[],
            use_reranking=False
        )

        # Should return HybridRetriever instance
        assert isinstance(retriever, HybridRetriever)

    def test_pipeline_with_bm25(self, mock_vector_store, sample_security_documents):
        """Test pipeline with BM25 components"""
        # Create a real BM25 index for this test to avoid Pydantic validation issues
        from rank_bm25 import BM25Okapi
        tokenized = [doc.page_content.lower().split() for doc in sample_security_documents]
        real_bm25_index = BM25Okapi(tokenized)

        retriever = create_hybrid_retrieval_pipeline(
            vector_store=mock_vector_store,
            bm25_index=real_bm25_index,
            bm25_chunks=sample_security_documents,
            use_reranking=False
        )

        # Should return HybridRetriever with BM25 components
        assert isinstance(retriever, HybridRetriever)
        assert retriever.bm25_index == real_bm25_index
        assert retriever.bm25_chunks == sample_security_documents


class TestEdgeCases:
    """Test edge cases and error conditions"""

    def test_empty_query(self, hybrid_retriever_no_bm25):
        """Test handling of empty query"""
        with patch.object(hybrid_retriever_no_bm25, '_vector_search') as mock_vector:
            mock_vector.return_value = []
            results = hybrid_retriever_no_bm25._get_relevant_documents("")

            # Should handle gracefully
            assert isinstance(results, list)

    def test_query_with_special_characters(self, hybrid_retriever_no_bm25):
        """Test query with special characters"""
        with patch.object(hybrid_retriever_no_bm25, '_vector_search') as mock_vector:
            mock_vector.return_value = []
            results = hybrid_retriever_no_bm25._get_relevant_documents("CWE-89: SQL'; DROP TABLE--")

            assert isinstance(results, list)

    def test_very_long_query(self, hybrid_retriever_no_bm25):
        """Test handling of very long query"""
        with patch.object(hybrid_retriever_no_bm25, '_vector_search') as mock_vector:
            mock_vector.return_value = []
            long_query = "SQL injection vulnerability " * 100
            results = hybrid_retriever_no_bm25._get_relevant_documents(long_query)

            assert isinstance(results, list)

    def test_bm25_with_zero_scores(self, hybrid_retriever_with_bm25):
        """Test BM25 search when all scores are zero"""
        with patch.object(hybrid_retriever_with_bm25.bm25_index, 'get_scores') as mock_scores:
            mock_scores.return_value = np.array([0.0, 0.0, 0.0, 0.0])

            results = hybrid_retriever_with_bm25._bm25_search("test", [])

            # Should still return documents even with zero scores
            assert isinstance(results, list)


class TestIntegration:
    """Integration tests for complete retrieval workflow"""

    def test_complete_retrieval_workflow(self, mock_vector_store, sample_security_documents):
        """Test complete retrieval workflow"""
        # Setup mock to return documents
        mock_retriever = Mock()
        mock_retriever.invoke.return_value = sample_security_documents[:2]
        mock_vector_store.as_retriever.return_value = mock_retriever

        retriever = create_hybrid_retrieval_pipeline(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[],
            use_reranking=False
        )

        # Perform retrieval
        results = retriever.invoke("SQL injection vulnerability")

        assert isinstance(results, list)
        assert len(results) > 0
        assert all(isinstance(doc, Document) for doc in results)

    def test_retrieval_returns_security_content(self, mock_vector_store, sample_security_documents):
        """Test that retrieval returns security-related documents"""
        # Setup mock to return documents
        mock_retriever = Mock()
        mock_retriever.invoke.return_value = sample_security_documents
        mock_vector_store.as_retriever.return_value = mock_retriever

        retriever = create_hybrid_retrieval_pipeline(
            vector_store=mock_vector_store,
            bm25_index=None,
            bm25_chunks=[],
            use_reranking=False
        )

        results = retriever.invoke("CWE SQL injection")

        # Verify returned documents contain security content
        assert any('CWE' in doc.page_content or 'vulnerability' in doc.page_content.lower()
                  for doc in results)